# 자료구조란?

- **메모리를 효율적으로 사용하며 빠르고 안정적으로 데이터를 처리하는 것**이 궁극적인 목표
- **상황에 따라 유용하게 사용될 수 있도록 특정 구조를 이루고 있는 것**이다.

# Array와 List

## Array

- **인덱스와** 인덱스에 해당하는 **요소로** 구성된다
- 고정적인 크기를 가진 선형 자료구조이다
- 메모리에 고정된 크기를 할당 받는다 (**정적 메모리** 할당)
- 데이터가 메모리에 순차적으로 저장된다 (메모리 주소도 연속적이다)
    - 배열의 **논리적 순서와 물리적 순서가 일치한다**
- 인덱스를 통해 빠르게 데이터에 접근 가능하다 → **Random Access**
- 시간복잡도
    - 검색: 인덱스를 안다면 O(1), 모른다면 O(N)
    - 추가/삭제: O(N)

## List

- 가변적인 크기를 가질 수 있는 선형 자료구조이다
- 새로운 요소가 추가될 때 런타임에 메모리를 할당한다 (**동적 메모리** 할당)
- 각 데이터는 다음 데이터가 저장된 메모리 주소를 가리킨다
    - 인덱스나 위치 같은 **물리적 배치 대신 참조 시스템** 사용
- 요소에 접근할 때 순차적으로 접근해야 함 → **Sequential Access**
- 시간복잡도
    - 검색: O(N)
    - 추가/삭제: O(1)

# ArrayList와 LinkedList

## ArrayList

- 가변적인 크기를 갖는 배열이다
    - 자동으로 크기를 1.5배로 늘리거나 0.5배로 줄여줌
    - **배열은 primitive type과 Object 모두를 담을 수 있지만 ArrayList는 Object element만 담을 수 있다**
    - **배열은 제네릭을 사용할 수 없지만 arrayList는 타입 안정성을 보장해주는 제네릭 사용 가능**
- 데이터 삽입, 삭제 시 평균 시간복잡도가 O(N)이다
    - 나머지 데이터를 순차적으로 밀어줌
- 데이터 접근 시 O(1)
- 순차적
- 인덱스로 접근 가능

## LinkedList

- 종류
    - 단방향으로 연결된 SingleLinkedList
    - 양뱡향으로 연결된 DoubleLinkedList
    - 원형 연결 리스트 Deque
- Stack, Queue 구현에 사용된다
- 인덱스로 접근 불가
- 정보 삽입, 삭제가 많이 일어날 때 사용한다
    - prev, next만 수정하면 됨
- 데이터 접근 시 O(N)

# Stack과 Queue

## Stack

- 후입선출(LIFO)
- **실행 취소, 수학적 표현식 분석, 재귀적 함수 호출**, DFS 등에 응용됨
- Push, Pop 메서드 사용
- 시간 복잡도
    - 검색: O(N)
    - 추가/삭제: O(1)

## Queue

- 선입선출(FIFO)
- **대기열 시스템, 멀티스레딩에서 스레딩 관리, 프로세스 스케줄링**, BFS 등에 응용됨
- Offer, Poll 메서드 사용
- LinkedList로 구현됨
- 시간 복잡도
    - 검색: O(N)
    - 추가/삭제: O(1)

## Deque

- Double-Ended Queue
- 큐의 양쪽으로 요소를 삽입, 삭제할 수 있음

## PriorityQueue

- 우선순위 큐: 우선순위가 높은 요소부터 차례대로 뽑힘
- 우선순위 큐에 저장할 객체는 필수적으로 **Comparable Interface를 구현**해야 함
- **Heap을 이용하여 구현**하는 것이 일반적임 — 정렬이 빨라서
    - 시간 복잡도: O(NlogN)

# Tree

- 노드와 엣지로 구성된 비선형 자료구조
- 최상위 노드(Root) 및 부모-자식 관계로 인해 계층적으로 구성됨
    - 트리에 또 다른 트리가 있는 **재귀적 자료구조**
- 사이클이 존재하지 않음

## Binary Tree

- 이진 트리
- 자식을 최대 2개 갖는 트리 → **차수가 2 이하**

## Perfect Binary Tree

- 포화이진트리
- **모든 리프 노드의 레벨이 동일하고 모든 레벨이 가득 채워짐** → 부모가 모두 자식을 2개 가짐

## Full Binary Tree

- 전이진트리 = **Balanced 균형이진트리**
- **노드 차수가 0 또는 2** 인 이진트리

## Complete Binary Tree

- 완전이진트리
- 왼쪽부터 차례대로 리프노드가 채워진 트리(**마지막 레벨을 제외하고 모든 노드가 가득 차** 있어야 함)
- 리프노드가 아닌 노드는 모두 자식을 2개 가져야 함

## Binary Search Tree

- 이진탐색트리
- **노드에 저장된 값은 유일한 값** → 중복 값 없음
- 부모 노드보다 작은 값의 노드는 왼쪽 자식에, 큰 값의 노드는 오른쪽 자식에 위치함
- 시간 복잡도
    - 평균 탐색 시간: O(logN)
    - 최악 탐색 시간: O(N)

![image](https://github.com/SWM-IDLE/tech-interview/assets/78717113/ef19c637-a732-4ae7-9036-a3742464b2cc)


## Red Black Tree

- 편향트리를 극복하기 위해 만들어짐 → **Rebalancing 기법** 중 하나
- 다음과 같은 규칙을 따른다
    - 각 노드는 Red 또는 Black이라는 색깔을 가진다
    - 루트 노드는 Black이다
    - 각 리프 노드(NIL)는 Black이다
    - 어떤 노드의 색이 Red라면, 두 자식 노드의 색은 Black이다
    - **어떤 한 노드로부터 리프 노드(NIL)까지의 Black의 수는 리프 노드를 제외하면 모두 같다 — 이를 Black-Height라고 한다**
    
    ![image](https://github.com/SWM-IDLE/tech-interview/assets/78717113/3fc3429d-f409-4738-9eed-693890a78fc5)

    
- 특징
    - BST의 특징을 갖춤
    - 루트로부터 리프 노드까지의 **최소 경로는 최대 경로의 두 배보다 크지 않음 → Balanced 한 상태**
    - 노드의 자식이 없을 경우, 자식을 가리키는 포인터에 NIL 값을 저장함 → NIL 노드들을 리프 노드(Black)로 간주함

# Heap

- **완전이진트리**
    - 최소 힙: 부모의 키 값이 자식의 키 값보다 작거나 같음
    - 최대 힙: 부모의 키 값이 자식의 키 값보다 크거나 같음
- **최솟값, 최댓값을 최대한 빠르게 찾아내기 위해** 고안됨
    - 우선순위 큐 구현에 사용됨
- **중복 허용, 그러나 BST에서는 중복 값 불가**

# Hash Table

- **키(Key)와 값(Value)** 로 데이터를 저장하는 자료구조 → **빠른 검색** 가능
- **연결 리스트와 해시 함수**가 필요함
    - 해싱(Hashing): 해시 함수를 통해 **임의의 값을 고정된 크기의 값으로** 변환하는 작업
    - 키 값을 입력 받아서 해시 함수를 통해 얻은 **해시를 배열의 인덱스로 환산**해서 값에 접근
- 데이터가 저장되기 이전에 미리 공간 할당 → **공간 복잡도가 큼**
- 시간 복잡도
    - 검색/추가/삭제: 평균 O(1)
    - 충돌이 일어나는 최악 경우 O(N)

## Hash Function

- 어떤 값에 해시 함수를 적용했을 때, 해시 값이 최대한 겹치지 않아야 하기 때문에 주로 소수를 사용한 해시 함수가 활용됨

## Resolve Collision

- 해시값 충돌을 해결하기 위한 방법들

### Open Addressing

- 개방 주소법
- **해시 테이블의 빈 공간 사용** → 추가적인 메모리 공간 필요 X
    - **Linear Probing**: 순차적으로 탐색해 다음 인덱스를 찾음
    - **Quandratic Probing**: 2차 함수를 이용해 탐색할 위치를 찾음
    - **Double Hashing**: 새로운 해시 함수를 활용해 주소를 찾음

### Separate Chaining

- 분리 연결법
- 충돌이 발생하는 경우 **인덱스가 가리키고 있는 값에 노드를 추가**하여 값을 추가함

## Resize

- 해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능 상 손실이 발생
- **key-value 쌍 데이터 개수가 일정 개수 이상(75%)이 되면 해시 버킷의 개수를 두 배로 증가시킴**

## Hash Map vs Hash Table

- Thread-safe 여부
    - **Hash Table은 Thread-safe 하고 Hash Map은 그렇지 않다**
- Null 값 허용 여부
    - **Hash Table은 Key에 Null을 허용하지 않지만 Hash Map은 Null을 허용**
- **Hash Map은 보조해시를 사용함 → Hash Table에 비해 해시 충돌이 덜 발생**
- 최근까지 Hash Table은 구현에 거의 변화가 없지만 **Hash Map은 지속적으로 개선 되는 중**
- **Concurrent Hash Map: Hash Table은 읽기, 쓰기 모두 동기화 지원 but Concurrent Hash Map은 쓰기에서만 동기화 지원**

# Graph

- 노드와 엣지로 이루어진 비선형 자료구조
- 계층 관계가 아니라 단방향, 양방향 연결 관계로 이루어짐
- 사이클이 존재할 수 있음
- 시간 복잡도
    - 두 노드의 연결 확인
        - 인접 행렬: O(1)
        - 인접 리스트: O(N)
    - 한 노드에 연결된 모든 노드 확인
        - 인접 행렬: O(N)
        - 인접 리스트: O(E)
    - 추가/삭제
        - 추가: 노드와 엣지 모두 O(1)
        - 삭제: 노드 삭제 O(V+E), 엣지 삭제 O(E)

## Graph 구현

- 인접 행렬
    - arr[x][y] = true: x 노드와 y 노드가 연결됨
- 인접 리스트
    - list.get(x) = {a, b, c}: x 노드에 a, b, c 노드가 연결됨

## Graph 탐색

- 깊이 우선 탐색(DFS)
    - 재귀 또는 스택으로 구현
    - 연결된 리프노드까지 쭉 탐색 후 다시 분기점으로 돌아와서 리프노드까지 쭉 탐색 ,, 반복
    - 백트래킹에 응용됨
- 너비 우선 탐색(BFS)
    - 큐로 구현
    - 노드에 연결된 모든 노드들을 탐색한 뒤 그 다음 노드에 연결된 노드들을 쭉 탐색 ,, 반복
    - 최단거리탐색에 응용됨

## 최소 스패닝 트리

- 스패닝 트리: Graph의 모든 노드들을 연결한 트리(사이클이 없음)
    - = 최소 연결 부분 그래프
    - N-1개의 간선으로 이루어짐
- 최소 스패닝 트리: 간선의 가중치의 합이 최소가 되도록 구성한 스패닝 트리

### Kruskal 알고리즘

- 간선 지향
- Union Find 메서드 활용
- 간선의 가중치를 오름차순으로 정렬 후, 차례대로 간선을 뽑아가며 노드를 연결함 — **탐욕적인 방법(Greedy) 이용**
    - 이미 연결된 노드라면 해당 간선은 pass — 사이클이 형성되지 않도록

### Prim 알고리즘

- 정점 지향
- 시작 정점에서부터 제일 가까운 정점을 연결함 — **단계적으로 확장**
    - 연결된 집합과 제일 가까운 정점을 연결함 → 모두 연결되었다면 종료
- 연결되었는지 여부를 판단하는 boolean 배열과 연결된 집합들과 제일 가까운 거리를 저장하는 int 배열이 사용됨

# QnA

- **Array의 가장 큰 특징과 그로 인해 발생하는 장점과 단점**
    - Array의 가장 큰 특징은 순차적으로 데이터를 저장하는 것
    - 따라서 Index를 통해 특정 요소를 찾기 용이하지만 중간에 데이터가 삽입/삭제되면 그 뒤의 요소들을 한 칸씩 밀거나 당겨줘야 함
    
- **Array와 ArrayList의 차이**
    
    - Array는 고정적인 크기, ArrayList는 가변적인 크기 — 배열이 꽉 차면 더 큰 사이즈의 배열을 선언해 기존 값들을 옮겨줌
    - Array는 primitive type, Object 모두 담을 수 있지만 ArrayList는 Object만 담을 수 있음
    - Array는 제네릭 사용 불가, ArrayList는 가능
    
- **Stack과 Queue의 실사용 예를 들어 간단히 설명**
    
    - Stack은 재귀 함수 호출에 사용 — 최근에 호출된 함수부터 차례대로 실행되어야 하므로 후입 선출 구조의 Stack 활용
    - Queue는 OS의 프로세스 스케줄링에 사용 — 먼저 자원을 요청한 프로세스부터 차례대로 자원이 할당되어야 하므로 선입 선출의 Queue 활용
    
- **Array와 List의 장/단점에 대해 설명**
    
    - Array는 빠른 데이터 접근이 가능하지만 삽입, 삭제 시 시간 소모
    - List는 순차적으로 탐색하며 데이터에 접근해야 하지만 삽입, 삭제가 빠름
    
- **해시 테이블과 시간 복잡도에 대해 설명**
    
    - 해시 테이블은 해시 함수를 통해 해싱된 해시 값에 Key, Value를 저장
    - 미리 충분한 크기의 배열을 선언 해야되기 때문에 공간 복잡도는 높음
    - 평균적으로 해시 값을 통해 바로 데이터에 접근할 수 있어 O(1)의 시간 복잡도를 가지지만
    - 해시 충돌이 극단적으로 많이 일어난 경우 O(N)의 시간 복잡도로 접근해야될 수 있음
    
- **Hash Map과 Hash Table의 차이점**
    
    - Hash Table은 Tread-safe 하지만 HashMap은 Tread-safe하지 못함
    - Hash Table은 키 값에 Null을 허용하지 않지만 Hash Map은 Null 값을 허용함
    - Hash Map은 이중 해시를 통해 해시 충돌 가능성을 낮춤
    
- **해시 충돌 해결 기법 설명**
    - Open Addressing: 해시 충돌 시 해시 테이블에 빈 공간을 찾아 값을 넣어줌 — 순차 탐색, 제곱 탐색, 이중 해싱 등을 통해
    - Separate Chaining: 해시 충돌 시 해당 위치의 연결 리스트에 값을 추가함
    
- **선형 자료구조와 비선형 자료구조 각각 어떤 것이 있는지**
    - 선형: Array, List, Stack, Queue
    - 비선형: Tree, Graph
