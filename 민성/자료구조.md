### Array & Linked List

### Array

- 정의와 동시에 크기를 지정하며, 크기를 변경할 수 없다.
- 배열의 물리 주소와 논리 주소는 동일하다. 특성 덕분에 인덱스 연산자를 이용할 수 있다.
- 메모리 공간이 연속적으로 구성된다.
- 데이터의 크기가 확정적일 때 배열을 사용하는 것은 메모리나 처리속도 면에서 좋다.
- 시간복잡도 O(n)
    - 배열 중간에 있는 원소 제거시
    - 배열 중간에 원소 삽입시
- 시간복잡도 O(1)
    - 특정 위치에 있는 원소 접근
    - 특정 위치에 있는 원소 수정

### List (java)

- 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 컬렉션 프레임 워크의 주요 인터페이스 중 하나
- List : 순서가 있는 데이터 집합, 중복 허용
- Set : 순서가 없는 데이터 집합, 중복 허용 X
- 배열과 다른 점은 저장 공간의 크기가 고정되지 않고 가변적이고, 중간에 빈 공간을 허용하지 않는다.

### ArrayList

- 탄생배경
    - 내부적으로 Array을 이용하여 요소를 저장하는 자료구조로, 배열의 정적인 크기의 한계점을 극복
- 배열의 요소를 복사하여 새로운 배열로 옮기는 과정은 동일하다. 우리 눈에 안보일 뿐!
- Array와 차이점
    - 배열 리스트의 저장 공간 크기가 가변적인 것처럼 만들어주는 것
    - 배열에서 지원하지 않는 List 인터페이스에서 정의한 다양한 메서드 지원
    - 배열을 확장시키거나 중간에 원소를 삽입/삭제하여 발생하는 번거로운 일을 메서드로 해결

### LinkedList

- 탄생배경
    - 배열 리스트는 배열의 정적인 크기라는 한계를 극복하기 위해 탄생했지만, 아직 삽입/삭제할 때 시간복잡도가 O(n)인 한계점이 있다.
- 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료구조
    - 단방향 연결 리스트와 양방향 연결 리스트가 존재
    - java LinkedList는 양방향 연결 리스트
- 물리 공간과 논리 공간이 일치하지 않으며, 메모리 공간이 연속적으로 구성되어 있지 않는다.
    - 인덱스 연산자를 사용할 수 없다.
- 시간복잡도 O(1)
    - 배열 중간에 있는 원소 제거시
    - 배열 중간에 원소 삽입시
    - 새로운 원소가 삽입되거나 삭제될 때, 저장 공간을 확장하거나 축소하여 재할당해줄 필요가 없다.
- 시간복잡도 O(n)
    - 특정 위치에 있는 원소 접근
    - 특정 위치에 있는 원소 수정

### 결론

<img width="725" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/71378475/e5ca50fc-6d65-4f5a-9724-7309df5abb9d">

- Java에서의 ArrayList
    - Java에서 ArrayList는 Default Size는 10이며, capacity를 넘어서면 배열 크기의 1.5를 증가 시킨다.
        - ArrayList 내부 코드
        
        <img width="774" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/71378475/aa548275-91a4-4a46-bae9-abdf61c77c91">
        
        |  | Array | ArrayList |
        | --- | --- | --- |
        | 사이즈 | 초기화시 고정 | 초기화시 사이즈를 표시 |
        | 속도 | 초기화시 메모리에 할당되어 속도가 빠름 | 초과시 메모리를 재할당하여 속도가 느림 |
        | 제네릭 | 사용 불가능 | 사용 가능 |
        | Primitives | primitive type, Object | 오직 Object |
        | Length | array.length | arraylist.size() |
        
<hr/>

### Stack & Queue

### 스택

- 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질 (LIFO)
- 웹 브라우저 방문 기록, 실행 취소, 깊이 우선 탐색 등에 사용
- 삽입 및 삭제 O(1), 탐색 O(n)

### 큐

- 먼저 넣은 데이터가 먼저 나오는 성질 (FIFO)
- CPU 작업을 기다리는 프로세스, 스레드 행렬 또는 네트워크 접속을 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용
- 삽입 및 삭제 O(1), 탐색 O(n)
- 선형큐 vs 원형큐
    - [https://j3sung.tistory.com/742](https://j3sung.tistory.com/742)

### 덱 (Deque)

- Double - Ended Queue
- 한쪽에서만 삽입, 다른 한쪽에서 삭제가 가능했던 큐와 달리 양쪽에서 삽입/삭제가 가능하다.
- 삽입 및 삭제 O(1), 탐색 O(1)

<hr/>

### Tree

**노드로 이루어진 자료구조**

- 하나의 루트 노드를 가진다.
- 루트 노드는 0개 이상의 자식 노드를 가지고 있다.
- 그 자식 노드 또한 0개의 이상의 자식 노드를 갖고 있고, 이는 반복적으로 정의
- 그래프의 한 종류, 사이클이 없는 하나의 연결 그래프이다.
- 노드가 N개인 트리는 항상 N-1개의 간선을 가진다.
    - 루트에서 어떤 노드로 가는 경로는 유일하다.
- 순회
    - Pre-Order : 왼쪽 → 현재 → 오른쪽
    - In-Order : 현재 → 왼쪽 → 오른쪽
    - Post-Order : 왼쪽 → 오른쪽 → 현재
- 트리 용어
    - 루트 노드
    - 리프 노드
    - 내부 노드 : 단말 노드가 아닌 노드

### Binary Tree

- 각 노드가 최대 두 개의 자식을 갖는 트리

### Binary Search Tree

- 모든 노드가 아래와 같은 특정 순서를 따르는 속성이 있는 이진 트리
- 모든 왼쪽 자식들 ≤ 자신 < 모든 오른쪽 자식들

### Full Binary Tree (전 이진 트리)

- 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리

### Complete Binary Tree (완전 이진 트리)

- 트리의 모든 높이에서 노드가 꽉 차 있는 이진 트리. 즉, 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있다.
- 마지막 레벨은 꽉 차 있지 않아도 되지만, 노드가 왼쪽부터 오른쪽으로 채워져야 한다.
- 배열를 사용하여 효율적으로 표현 가능하다.

### Perfect Binary Tree (포화 이진 트리)

- 모든 내부 노드가 두개의 자식 노드를 가진다.
- 모든 리프 노드가 동일한 깊이 또는 레벨을 갖는다.

### Red Black Tree

- 자가 균형 이진 탐색 트리
    1. 모든 노드는 빨간색 혹은 **검은색이다.**
    2. 루트 노드는**검은색이다.**
    3. 모든 리프 노드(NIL)들은 **검은색이다.**
    
    (NIL : null leaf, 자료를 갖지 않고 트리의 끝을 나타내는 노드)
    
    1. 빨간색 노드의 자식은 **검은색이다.**
    
    == No Double Red (빨간색 노드가 연속으로 나올 수 없다)
    
    1.  모든 리프 노드에서 Black Depth는 같다.
    
    == 리프노드에서 루트 노드까지 가는 경로에서 만나는 **검은색** 노드의 개수가 같다.
    

- 레퍼런스
    - [트리 자료구조](https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html)
    - [레드-블랙 트리 자료구조](https://code-lab1.tistory.com/62)

<hr/>

### Heap

- 완전 이진 트리의 일종으로 우선 순위 큐를 위해 만들어진 자료구조
- 여러 개의 값들 중 최소값이나 최댓값을 빠르게 찾아내도록 만들어진 자료구조.
- 힙 트리에서는 중복된 값을 허용하지만, 이진 탐색 트리에서는 중복된 값을 허용하지 않는다.
- 삽입, 삭제 : O(logn)

- 힙의 종류
    - 최대힙
        - 부모노드의 키값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
    - 최소힙
        - 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리
- 레퍼런스
    - [힙 자료구조](https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html)

<hr/>

### Hash Table

- (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조
- 각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색
- 실제 값이 저장되는 장소를 버킷 또는 슬롯이라고 한다.
- 해시 함수 1번만 수행하면 되므로 데이터를 저장/삭제/조회의 평균 시간복잡도는 O(1)이다.

### Hash Function

- 해시함수에서 중요한 것은 고유한 인덱스 값을 설정하는 것이다.

### Resolve Collision

- Open Addressing
    - 비어있는 해시 테이블의 공간을 활용
        - Linear Probing
            - 고정폭 만큼씩 이동하여 차례대로 검색해 비어 있는 버킷에 데이터 저장.
        - Quadratic Probing
            - 해시의 저장순서 폭을 제곱으로 저장하는 방식이다. 예를 들어 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식.
        - Double Hashing Probing
            - 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다. 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산
    - 데이터를 삭제하면 삭제된 공간은 Dummy Space로 활용되는데, 그렇기 때문에 Hash Table을 재정리 해주는 작업이 필요하다고 한다.
        
- Separate Chaining
    - 동일한 버킷의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 것
    - Java8의 Hash테이블은 Self-Balancing Binary Search Tree 자료구조를 사용해 Chaining 방식을 구현
    - 해시 테이블의 확장이 필요없고 간단하게 구현이 가능하며, 손쉽게 삭제할 수 있다는 장점이 있다. 하지만 데이터의 수가 많아지면 동일한 버킷에 chaining되는 데이터가 많아지며 그에 따라 캐시의 효율성이 감소한다는 단점

- Resize
    - 해시 테이블에 비어있는 원소가 적으면, 삽입에 실패하거나 해시성능이 급격히 적어지는 현상이 발생 → 적재율에 따라 달라진다.
        - 적재율이란 `테이블에 저장된 키의 수 / 테이블의 크기`
        - 적재율 ≥ 0.75 → 해시테이블의 크기를 2배
        - 적재율 ≤ 0.25 → 해시테이블의 크기를 1/2

- 레퍼런스
    
    [Java HashMap은 어떻게 동작하는가?](https://d2.naver.com/helloworld/831311)
    
<hr/>

### Graph

- 정점과 간선으로 이루어진 비선형 자료구조.
    - 비선형 자료구조 : 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조를 말한다.
- 용어정리
    - 정점 : 위치 개념 = node
    - 간선 : 정점들을 연결하는 선 = branch
    - 인접 정점 : 어떠한 정점에서 1개의 간선으로 직접 연결된 정점
    - 정점의 차수(Degree) : 무방향 그래프에서 하나의 정점에 인접한 정점의 수
    - indegree : 외부에서 들어오는 간선의 수 = 내차수
    - outdegree : 외부로 나가는 간선의 수 = 외차수
    - 가중치 : 간선과 정점 사이에 드는 비용
    - 사이클 : 단순 경로의 시작 정점과 종료 정점이 동일한 경우
- 종류
    - Directed Graph
        - 화살표 방향대로만 이동 가능
    - Undirected Graph
        - 방향 그래프와 다르게 양방향 이동 가능
    - Cycle
        - 단순 경로의 시작 정점과 종료 정점이 동일한 경
    - Acycle Graph
        - 사이클이 없는 그래프
    - Connected Graph
        - 모든 정점에 대해 항상 경로를 가지는 그래프
    - Disconnected Graph
        - 정점들 사이에 간선이 존재하지 않아 경로가 없는 경우가 존재하는 그래프
    - Sparse Graph
        - 정점의 개수보다 간선 개수가 적은 그래프
    - Dense Graph
        - 정점의 개수보다 간선 개수가 많은 그래프

### Graph 구현 - 중요한지 모르겠음
- [https://sarah950716.tistory.com/12](https://sarah950716.tistory.com/12) 참고

### Graph 탐색

- DFS
    - 루트 노드 시작하여 다음 정점을 탐색하기 전에 해당 정점을 완벽하게 탐색 후 다음 정점을 탐색하는 방법
    - Stack 자료구조 사용
    - O(V+E)
- BFS
    - 루트 노드 시작하여 인접한 정점을 먼저 탐색하는 방법
    - Queue 자료구조 사용
    - O(V+E)

<hr/>

### Minimum Spanning Tree

- Spanning Tree (신장 트리)
    - 그래프 내의 모든 정점을 포함하는 트리
    - 간선의 수가 가장 적게 최소로 연결 (n개의 정점을 가지는 그래프의 최소 간선의 수는 n-1개
    - 하나의 그래프에는 많은 신장 트리가 존재할 수 있다.
    - 모든 정점들이 연결되어 있어야 하고, 사이클이 존재하면 안된다.
    - 사용예시) 통신 네트워크 구축

- Minimum Spanning Tree
    - Spanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리
    - 간선의 가중치의 합이 최소이여야 하며, 신장 트리와 특징은 돌일하다.
    - 사용예시) 통신망, 도로망, 유통망에서 길이, 구축 비용, 전송 시간 등을 최소로 구축하려는 경우

- MST 구현 방법
    - Kruskal algorithm
        - 탐욕적인 방법 이용
            - 그래프의 간선들을 가중치의 오름차순으로 정렬
            - 정렬된 간선 리스트에 순서대로 사이클이 형성하지 않는 간선을 선택
                - 사이클 생성 여부를 확인하기 위해 union-find 알고리즘 사용
            - 해당 간선을 현재의 MST의 집합에 추가
        - Kruskal algorithm 시간복잡도는 간선들을 정렬하는 시간에 좌우된다.
            - 간선 e개를 퀵 정렬과 같은 효율적인 알고리즘으로 정렬 O(eloge)
            - 간선이 적은 Sparse Graph의 경우 적용하기 적합
    - Prim algorithm
        - 시작 정점에서부터 출발하여 신장트리 집합을 단계적으로 확장해나가는 방법
            - 시작 단계에서는 시작 정점만이 MST(최소 비용 신장 트리) 집합에 포함된다.
            - 앞 단계에서 만들어진 MST 집합에 인접한 정점들 중에서 최소 간선으로 연결된 정점을 선택하여 트리를 확장한다.
                - 즉, 가장 낮은 가중치를 먼저 선택한다.
            - 위의 과정을 트리가 (N-1)개의 간선을 가질 때까지 반복한다.
        - Prim algorithm 시간복잡도는 주 반복문이 정점의 수 n만큼 반복하고, 내부 반복문이 n번 반복 O(n^2)
            - 정점이 적고 간선이 많은 Dense Graph에 적합
    - 참고 레퍼런스
        - [크루스칼 알고리즘 참고](https://gmlwjd9405.github.io/2018/08/29/algorithm-kruskal-mst.html)
        - [프림 알고리즘 참고](https://gmlwjd9405.github.io/2018/08/30/algorithm-prim-mst.html)
    

### 그래프와 트리의 차이점

<img width="811" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/71378475/3f29f888-2264-43a4-92d8-5854611d87ce">
