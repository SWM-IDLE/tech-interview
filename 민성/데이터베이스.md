## 인덱스

### Index

- 추가적인 쓰기 작업과 저장 공간을 활용하여 **데이터베이스의 검색 속도를 향상하기 위한 자료구조**
- **Index를 통해 검색 속도 향상과 조회 성능을 높일 수 있다.**
- Index를 사용하지 않는 칼럼을 조회하는 상황에서는 테이블 전체를 탐색하는 Table Full Scan이 수행되어 처리 속도가 떨어진다.
- 인덱스를 활용하면, SELECT 외에도 UPDATE와 DELETE 성능을 향상할 수 있다.
    - UPDATE와 DELETE의 WHERE문에서 데이터를 조회하는 성능을 향상된다.

### **Index 적용 예시**

```sql
// single column index
CREATE INDEX si_id ON MEMBER (id);
CREATE INDEX si_name ON MEMBER (name);

// multi column index
CREATE INDEX mi_id_name ON MEMBER (id, name);
CREATE INDEX mi_id_name_age ON MEMBER (id, name, age);
```

### **Index 관리**

- Index를 관리하기 위해서는 데이터베이스의 약 10%의 저장공간이 필요하다.
- Index는 항상 최신의 정렬된 상태로 유지해야 원하는 데이터를 빠르게 탐색할 수 있다.
- 따라서 **Index에 적용된 칼럼에 INSERT, UPDATE, DELETE가 수행된다면, Index를 관리를 위한 추가적인 연산이 발생하여 그에 따른 오버헤드가 발생**한다.
    - **INSERT** : 인덱스 페이지(데이터가 저장되는 단위)가 꽉차면, 비어있는 페이지를 확보하고 문제 있는 페이지를 분할하는 과정에서 성능에 영향을 준다.
    - **DELETE** : 데이터를 실제 지우지 않고 "사용하지 않음" 처리를 한다.
    - **UPDATE** : DELETE - INSERT 순으로 동작한다.
- **DELETE와 UPDATE가 빈번하게 일어나는 칼럼에 대해서 index를 설정**하면, **인덱스의 크키가 비대해져 성능을 오히려 저하**시킨다.
    - DELETE와 UPDATE시 기존의 인덱스를 삭제하지 않고 **“사용하지 않음” 처리(삭제마킹)를 하기 때문에** 인덱스의 크기가 커져, 처리 성능이 떨어진다.

### **어떤 칼럼에 Index를 설정하는 것이 좋을까?**

- **수정 빈도** : INSERT, UPDATE, DLELTE가 자주 발생하지 않는 칼럼
- **활용도** : Join과 where, order by에 자주 사용하는 칼럼
- **중복도** : 데이터의 중복도가 낮은 칼럼 (**카디널리티**가 높음)
- 규모가 작지 않은 테이블

### **Index 장단점**

- 장점
    - 특정 칼럼에 대해서 **조회 시, 검색 속도 성능을 향상할** 수 있다.
    - 전반적인 시스템 부하를 줄일 수 있다.
- 단점
    - 인덱스를 관리하기 위해 **DB의 10%의 저장공간이 필**요하다.
    - **인덱스 관리를 위한 추가 작업이 필요**하다.
    - 인덱스를 잘못 사용할 경우 성능이 저하되는 역효과가 발생한다.

### **Index 자료구조**

- **해시 테이블**
    - Key, Value로 데이터를 저장하는 자료구조로, 빠른 데이터 검색이 필요할 때 유용하다.
    - **데이터베이스에서는 부등호(>, <)이 자주 일어나기 때문에, 등호(=) 연산에 특화된 해시테이블은 인덱스 자료구조로 적합하지 않다.**

<img width="449" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/71378475/52e1ed97-2ca5-4e42-a182-ea84581e0340">


- **B+ Tree**
    - DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조
    - **리프 노드만 인덱스와 함께 데이터를 저장하고 있고, 나머지 노드는 데이터를 위한 인덱스만 갖는다.**
    - **리프 노드는 Linked List로 연결**되어 있다.
    - 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.
        - 인덱스는 삭제되지 않고, 비활성화 처리되기 때문에 데이터 노드의 크기와 인덱스 노드의 크기가 다를 수 있다.
    - 데이터 베이스의 인덱스 칼럼은 **부등호를 이용한 순차 검색 연산이 자주 발생**한다. 따라서 B+ Tree의 리프 노드들을 Linked List로 연결하여 순차검색을 용이하게 하는 등 BTree를 인덱스에 맞게 최적화한 것이다.

<img width="626" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/71378475/65d9a264-ff32-436c-8c1c-7cef37727f92">

### **Index 주의사항**

- 잘 활용되지 않는 인덱스는 제거하자.
    - WHERE 절에 사용되더라도 자주 사용해야 가치가 있다.
    - 불필요한 인덱스는 성능 저하가 발생할 수 있다.
- **인덱스로 사용될 칼럼값 그대로 사용해야만 인덱스가 사용**된다.
    - **WHERE salary * 10 > 15000 (인덱스 적용 X)**
    - **WHERE salary > 15000 / 10 (인덱스 적용 O)**
- **복합 인덱스 순서가 중요**하다. (앞 순서의 조건은 반드시 포함시켜야 한다.)
    - 다음 칼럼이 이전 칼럼에 의존하여 정렬된다. 따라서 두 번째 칼럼만으로 질의를 하는 경우 인덱스를 잘 타지 못한다.
- **하나의 쿼리는 여러 인덱스 테이블을 동시에 탐색하지 않고 하나의 인덱스만 탐색한다.**
- **의도대로 인덱스가 동작하지 않을 경우 explain으로 확인**
    - **옵티마이저의 실행 계획을 확인**
    - 개발환경, 배포환경의 통계 내역이 다르기 때문에 따문에 옵티마이저 실행 계획이 다를 수 있다.
- 인덱스는 PK에 의존하기 때문에, **PK 값이 클수록** 한 페이지에 담을 수 있는 인덱스 정보가 줄어들고, 메모리를 비효율적으로 사용되기 때문에 성능에 좋지 않다.

### **클러스터링 인덱스 & 넌클러스터링 인덱스**

- **클러스터링 인덱스**
    - 클러스터링 : 실제 데이터와 무리를 이룸
    - 클러스터링 인덱스 : **실제 데이터와 같은 무리의 인덱스**
    - **인덱스로 지정한 컬럼을 기준으로 물리적으로 정렬하는 인덱스**
    - 우선순위 : 1) **primary key** 2) **unique + not null**
    - **실제 데이터 자체가 정렬**되어 있다.
    - **테이블당 1개만 존재 가능**하다.
    - 리프 페이지가 데이터 페이지와 동일하다.
    - 검색속도는 빠르지만, 입력, 수정, 삭제는 느리다.
- **넌클러스터링 인덱스**
    - 넌클러스터링 : 실제 데이터와 무리를 이루지 않음
    - 넌클러스터링 인덱스 : **실제 데이터와 다른 무리의 별도의 인덱스 (찾아보기 페이지)**
    - **데이터 자체는 정렬되지 않고, 인덱스값을 기준으로 정렬하여 새로 인덱스 페이지를 만드는 인덱스**
    - **unique column, unique index, index**
    - **실제 데이터 페이지는 그대로**
    - 별도의 인덱스 페이즈 생성 → 추가 공간 필요
    - 리프 페이지에 실제 데이터 페이지 주소를 담고 있다.
    - **테이블당 여러개** 존재 가능
    - 검색 속도는 Cluster에 비해 느리지만, 입력, 수정, 삭제가 빠르다.
- **예시**

```sql
CREATE TABLE member (
	id int primary key,
	name varchar(255),
	email varchar(255) unique
);
```

- 테이블 생성시 인덱스가 몇개 생성될까?
    - primary key → 클러스터링 생성
    - unique → 논-클러스터링 생성

### **테이블 스캔**

- **Table Full Scan**
    - 테이블에 속한 블록 전체를 읽어서 사용자가 원하는 데이터를 찾는다.
- **Index Range Scan**
    - 인덱스 칼럼이 가공되지 않는 상태로 조건절에 있을 때 수행
    - 인덱스의 일정량을 스캔하면서 얻은 ROWID를 사용해 테이블 레코드를 찾는다.
- **Index Full Scan**
    - 인덱스 칼럼이 조건에 없으면 Index Range Scan이 불가능하므로, 옵티마이저는 Table Full Scan을 고려한다.
    - 그런데 대용량 테이블이라면 Table Full Scan에 대한 부담이 너무 크면 Index를 활용할 필요가 있다.
    - 인덱스의 전체 크기는 테이블의 전체 크기보다 훨씬 적으므로, Index Range Scan을 할 수 없을 때 Full Table Scan보다는 Index Full Scan을 고려한다.

<br/>
<br/>

## 트랜잭션

### 트랜잭션(Transaction)이란?

- 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위
- DB에서 데이터를 다룰 때 장애가 일어난 경우 데이터를 복구하는 작업의 단위
- 트랜잭션은 전체가 수행되거나 또는 전체가 수행되지 않아야 한다. (ALL or Nothing)
- ex) 데이터베이스에 삽입, 수정, 삭제 등의 작업을 할 때, 여러 개의 작업들을 하나의 트랜잭션으로 묶습니다.

### 주요 용어

- **Commit**
    - 트랜잭션이 성공하여 트랜잭션 결과를 영구적으로 반영하는 연산
- **Rollback**
    - 트랜잭션 도중 실패하여 트랜잭션 실행을 취소하여 원래의 상태로 원상 복구시키는 연산

### 트랜잭션과 Lock

- 트랜잭션과 Lock은 비슷하지만,
- **Lock은 동시성을 제어하기 위한 기능**
    - 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할
- **트랜잭션은 데이터의 정합성을 보장하기 위한 기능**
    - 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미있는 개념은 아니다.
    - 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것
- **Lock은 내용이 많아 다음에 설명 ~**

### 트랜잭션의 특성 (ACID)

- **Atomicity** (원자성)
    - 트랜잭션이 원자처럼 더 이상 쪼개지지 않는 하나의 프로그램 단위로 동작해야 한다는 의미
    - 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.
- **Consistency** (일관성)
    - 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
    - ex) 어떤 테이블의 기본키와 같은 속성은 유지되어야 한다는 것 또는 A에서 B로 돈 이체를 할 때 A와 B계좌의 돈의 총합은 같아야한다는 것 등이 있습니다.
- **Isolation** (고립성)
    - 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야한다.
    - 두 개 이상의 트랜잭션이 동시에 발생할 때, 서로의 연산에 영향을 주면 안된다.
- **Durability** (영구성)
    - 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.
    

### 트랜잭션 격리수준

**1) READ UNCOMMITED**

- 트랜잭션에서 처리한 작업이 완료되지 않았음에도 불구하고 다른 트랜잭션에서 볼 수 있다.
    - 커밋하지 않는 내용을 다른 트랜잭션이 접근가능
- **DirtyRead** 발생
    - 데이터가 나타났다가 사라졌다하는 현상이 발생할 수 있다.
        - 트랜잭션 A → Begin → Insert/Update → Rollback
        - 트랜잭션 B                        → SELECT
        - 
<img width="425" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/71378475/4743d66a-5916-40b6-b1f0-af40cc7b5e50">
    

**2) READ COMMITED**

- 오라클 DBMS 디폴트 사용
- **커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회 가능**
- 어떤 트랜잭션에서 변경한 내용이 커밋되기 전까지는 다른 트랜잭션에서 그러한 변경 내역을 조회할 수 없다.
    - 커밋한 내용을 다른 트랜잭션이 접근 가능
    - **다른 트랜잭션이 수정한 필드를 가져오는 경우 UNDO 영역에서 백업된 레코드를 가져온다. ⇒ Dirty Read는 발생하지 않음.**
        
    <img width="425" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/71378475/0a815f4a-cc9c-49d7-82d9-2bedf1b5b1be">
   
    - **NON-REPEATABLE READ 발생**
    - 하나의 트랜잭션 내에서 동일한 SELECT 쿼리를 실행하였을 대 항상 같은 결과를 보장해야하는 Repeatable read 정합성에 어긋난다.
    - 일반적인 애플리케이션에서는 크게 문제가 되지않지만, 하나의 트랜잭션에서 동일한 데이터를 여러번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있다.
  
  <img width="425" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/71378475/47cefc96-473a-4321-8374-d853ca011fd3">

        
    

**3) REPEATABLE READ**

- **트랜잭션 내에서 한번 조회한 데이터를 반복해서 조회해도 결과는 동일하다.**
- Mysql의 InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준
    - ~~InnoDB는 트랜잭션이 Rollback될 가능성에 대비해 변경되기 전에 레코드를 언두 영역에 백업해두고 실제 레코드 값을 변경~~
    - ~~MVCC 라고 한다.~~
        - ~~다중 버전 병행수행 제어, DBMS에서 쓰기 세션이 읽기 세션을 블로킹하지 않고, 읽기 세션이 쓰기 세션을 블로킹하지 않게 서로 다른 세션이 동일한 데이터에 접근했을 때 각 세션마다 스냅샷 이미지를 보장하는 메커니즘~~
    - ~~REPEATABLE READ는 언두 영역에 백업된 이전 데이터를 통해 동일한 트랜잭션 내에서 동일한 결과를 보여줄 수 있도록 보장~~
- 모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호(순차적으로 증가하는 값)를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있습니다.
- 자신보다 트랜잭션 ID가 작은 트랜잭션 번호에서 변경한 것만 보게 한다.
    
    ⇒ Non-Repeatable Read 이 발생하지 않음
    
   <img width="425" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/71378475/4afebcd5-fff3-4bc0-9a74-839031624dcc">

    - **Phantom read 발생**
        - **다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안보였다가 하는 현상**
            - Update가 아닌 Insert와 delete로 인해
            - SELECT .. FOR UPDATE 쿼리는 SELECT하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없습니다.
            따라서 위와 같은 쿼리는 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오게 됩니다.
        
     <img width="425" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/71378475/25364cb9-eabd-4c09-b0b4-828114ff8905">

    - 하지만 **InnoDB에서는 독특한 특성 때문에 REPEATABLE READ 격리 수준에서도 PHANTOM READ가 발생하지 않는다고 합니다.**
    - 따라서 MySQL의 InnoDB 스토리지 엔진에서는 주로 REPEATABLE READ 격리 수준을 사용하는 것 같다.

**(참고) MySQL InnoDB 스토리지 엔진에서 REPEATABLE READ 격리 수준에서 PHANTOM READ가 발생하지 않는 이유**

- InnoDB의 다중 버전 동시성 제어(MVCC, Multi-Version Concurrency Control) 메커니즘
    - MVCC는 각 트랜잭션에 대해 데이터의 이전 버전을 유지하고, 각 트랜잭션에게 일관된 스냅샷을 제공하는 방식
    - **트랜잭션의 시작 시점에서 스냅샷이 생성**됩니다. **이 스냅샷은 해당 트랜잭션이 읽은 데이터의 일관성을 유지하기 위해 사용**됩니다. InnoDB는 새로운 데이터를 삽입하거나 기존 데이터를 변경할 때 해당 데이터의 이전 버전을 유지하면서 새로운 버전을 생성합니다. 새로운 버전은 트랜잭션이 커밋될 때까지 다른 트랜잭션에게 보이지 않습니다.
    - REPEATABLE READ 격리 수준에서 InnoDB는 쿼리를 실행할 때 트랜잭션의 스냅샷을 사용하므로, 다른 트랜잭션에 의해 새로운 행이 삽입되어도 해당 트랜잭션이 그 행을 볼 수 없게 됩니다.
- InnoDB 스토리지 엔진은 레코드 락과 갭 락을 합친 넥스트 키 락을 사용??

**4) SERIALIZABLE**

- 읽기 작업도 공유 잠금을 획득해야 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경할 수 없다.
- **트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없습니다.**

**5) 정리**

<img width="478" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/71378475/0d807b2e-78ef-46c1-adf3-514b2dbf0112">

**(참고)**

**언두 레코드**

- InnoDB의 시스템 테이블 스페이스의 언두 영역에 기록이 되는데,
- 트랜잭션 격리 수준을 보장하기 위한 용도뿐 아니라 트랜잭션의 ROLLBACK에 대한 복구에도 사용

**언두 로그**

- UPDATE, DELETE와 같은 문장으로 데이터를 변경했을 때, 변경되기 전의 데이터를 보관하는 곳
- 사실 Update문을 하였을 때, 실제 테이블에는 반영된 상태이며, 변경되기 전 데이터는 언두영역에 저장한다.
- 커밋한다면 그대로 유지하고, 롤백된다면 언두 영역에서 데이터를 다시 가져온다.

### 트랜잭션의 상태

<img width="636" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/71378475/74a4d00b-60e1-4232-9ba2-69bda83c4fd0">

- **Active** (활동)
    - 트랜잭션이 실행 중인 상태
- **Failed** (장애)
    - 트랜잭션이 실행에 오류가 발생하여 중단한 상태
- **Aborted** (철회)
    - 트랜잭션이 비정상적으로 종료되어 Rollback 수행하는 상태
- **Partially Commited** (부분 완료)
    - 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전인 상태
- **Committed** (완료)
    - 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태
- **Partially Commited와 Committed의 차이점**
    - Partially Commited은 Commit 요청이 들어왔을 때
    - Commited은 Commit을 정상적으로 완료하였을 때

### 트랜잭션을 사용할 때 주의할 점

- 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.
    - 즉 트랜잭션 범위를 최소화하는 것이 중요
    - 일반적으로 데이터베이스 커넥션 개수는 제한이라, 커넥션을 소유하는 시간이 길어지면 사용 가능한 여유 커넥션의 개수도 줄어들게 된다.
    - 커넥션이 부족하면 커넥션을 기다리는 요청이 많아진다.
    - 따라서 교착상태가 발생하지 않도록 유의해야 한다.!
- 교착 상태의 빈도를 낮추는 법
    - 트랜잭션을 자주 커밋한다. → 트랜잭션 범위를 최소화
    - 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다.

**(참고) 커넥션 풀**

- 클라이언트 요청에 따라 각 애플리케이션의 스레드에서 데이터베이스에 접근하기 위해서는 커넥션이 필요하다.
- 커넥션 풀이란 **미리 일정 수의 Connection을 만들어 풀에 보관해 두는 것**을 의미
    - 사용자의 요청에 따라 Connection을 생성하다 보면 많은 수의 연결이 발생했을 때 서버에 과부하가 걸리게 되므로 방지하기 위함
    - 커넥션 풀을 사용하면 생성, 소멸에 시간 소요가 없어지기 때문에 효율적
    - 한번에 사용할 수 있는 커넥션 수가 제어되어 애플리케이션이 쉽게 죽지 않음
