## 운영체제 (OS, Operating System)

- 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 시스템 소프트웨어

### 부팅 (Booting)

<img width="602" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/dc7ee0a4-e549-4f05-bbb6-9813bb407f89">

- ROM : 비휘발성으로 메모리에서 극히 일부를 차지 (수 KB)
- RAM : 휘발성으로 메모리의 대부분을 차지하며 실제 프로그램이 할당되는 곳 (수 MB ~ 수 GB)
- 부팅 순서
    
<img width="611" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/d978f97f-b59f-4510-9fb4-b1f132875c2c">
    
    - 프로세서(CPU)에서 ROM에 있는 내용을 읽는다.
        - ROM ⇒ POST(Power-On Self-Test), 부트 로더(boot loader)
    - POST는 전원이 켜지면 가장 처음 실행되는 프로그램으로 현재 컴퓨터 상태를 검사한다.
    - POST 작업 이후, 부트 로더가 실행된다.
    - 부트 로더는 하드디스크에 저장되어 있는 OS를 찾아 메인 메모리(RAM)에 가지고 온다.
    - 이러한 부트 로더의 과정을 부팅이라고 한다.
    
<img width="640" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/af9f5f50-3e32-474a-be2a-69a61220b110">

### 커널 (Kernel)

- 운영체제의 핵심, 운영체제가 수행하는 모든 것이 저장됨

### 명령어 해석기 (Command interpreter, shell)

- 사용자가 커널에 요청하는 명령어를 해석하여 커널에 요청하고, 그 결과를 출력

---

## 프로세스 관리

### 용어

- **프로그램** : 파일 단위로 저장장치에 저장되며, 아직 실행되지 않은 코드 덩어리를 의미
- **프로세스** : 실행 중인 프로그램, 운영체제로부터 주소 공간, 메모리 등을 할당받은 프로그램을 의미
- **스레드** : 프로세스의 실행 단위, 같은 프로세스 내 스레드끼리는 프로세스의 자원을 공유

### 프로세스 (Process)

- 운영체제로부터 메모리 공간을 할당 받아 실행중인 프로그램

### 프로세스에 할당되는 메모리 영역

<aside>
💡 코드(Code), 데이터(Data), 힙(Heap), 스택(stack) 영역

</aside>

<img width="705" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/abefd9d2-dd01-44bc-bb83-41298764f0d4">

- **코드** : 프로세스가 실행할 코드가 기계어 형태로 저장된 공간
    - 컴파일 타임에 결정, Read-Only
- **데이터** : 전역 변수, static 변수 등이 저장된 공간
    - 위 변수를 참조한 코드는 컴파일하고 나면 데이터 영역의 주소값을 가르킨다.
    - 컴파일 타임에 결정, Read-Write (실행 도중 변경 가능)
- **힙** : 프로그래머가 관리하는 메모리 영역
    - 힙 영역에 메모리 할당 → 동적 할당
    - 런타임에 결정
    - 스택보다 할당할 수 있는 메모리 공간이 많으나 데이터 읽고 쓰기가 느리다는 단점 존재
- **스택** : 함수 안에 선언된 지역변수, 매개변수, 리턴값, 복귀 주소 등을 저장
    - LIFO 방식으로 함수 호출 시 기록하고 종료되면 제거
    - 컴파일 타임에 결정
    - 정해진 크기로 인해 stack overflow 에러가 발생할 수 있음

---

## PCB와 Context Switching

### 프로세스 제어 블록 (Process Control Block, PCB)

<img width="701" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/63d36be3-09a1-4db8-928e-c56b512e69c3">

- 특정 프로세스에 대한 정보를 담고 있는 운영체제의 자료구조
- PCB 생성 및 동작 원리
    1. 프로세스는 운영체제의 스케줄링 알고리즘에 따라 CPU 할당
    2. 작업 진행 중 프로세스 전환이 발생하면 하던 일을 저장하고 CPU 반환
    3. 이후, 스케줄링에 의해 재실행 됐을 때, 이전에 어디까지 작업이 진행되었는지 정보를 찾게 됨 
    4. 해당 정보가 담긴 공간이 PCB
        1. 프로세스 생성과 동시에 해당 프로세스의 고유한 PCB도 함께 생성
- 위 사진에서 프로세스 각 주소 공간에 생성된 메타데이터들이 PCB에 저장됨

### Process Metadata + PCB에 저장되는 정보

- 프로세스 식별자 (PID)

<img width="692" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/2c2b8e67-8991-4129-9bd8-7bfad9d772b2">

- 프로세스 상태 : new, ready, running, waiting(blocked), terminated
- 프로그램 카운터 : 프로세스가 다음 실행할 명령어의 주소를 가리킴
- CPU 레지스터 : Accumulator, Index Register, 범용 레지스터 등
- CPU 스케줄링 정보 : 프로세스 우선순위, 최종 실행 시각, CPU 점유 시간 등
- 그 외 : 메모리 관리 정보, 계정 정보, 입출력 상태 정보

### PCB의 필요성과 관리

<img width="730" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/978a25c1-d78f-4d7c-93da-a123d422c159">

- CPU에서 프로세스 상태에 따른 교체 작업 발생 → 다시 수행할 대기 중인 프로세스에 관한 저장값을 PCB에 저장하여 기록하기 위해 필요
- Linked List 방식으로 관리하여 삽입과 삭제가 용이하다.
    - 프로세스 생성시 해당 PCB 생성, 프로세스 완료시 제거
        - 추가로, Linked List 방식의 관리는 Ready, Block 도 같다.

### 컨텍스트 스위칭 (Context Switching)

<aside>
💡 Ready → Running, Running → Ready, Running → Waiting 처럼 상태 변경 시 발생

</aside>

- CPU가 이전 프로세스 상태를 PCB에 보관, 또 다른 프로세스 정보를 PCB에 읽어 레지스터에 적재하는 과정
    - Context란 CPU가 프로세스를 실행하기 위한 정보로 PCB에 저장되는 정보들이 해당
    - 또는, 현재 CPU가 실행하고 있는 프로세스 정보 (문맥, Context)
- 컨텍스트 스위칭 동작 과정
    
   <img width="470" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/a31ff22c-07b4-4a80-a05c-b58c3be21a3f">
    
- 해당 동작은 CPU의 자원이 어떤 프로세스에 할당된 상태가 아니기 때문에 CPU가 아무 작업도 할 수 없음

### Overhead - Context Switching

- Overhead는 일반적으로 부정적이지만, 프로세스 작업 중에 감수해야하는 상황이 존재
- CPU에 계속 프로세스를 수행시키도록 다른 프로세스를 실행시키고 Context Swtiching 수행
    - CPU가 놀지 않도록 하여 사용자에게 빠르게 일처리를 제공시키는 효율성이 장점
- 단, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생할 문제 존재

---

## 스레드 (Thread)

<img width="721" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/e6fb0a15-f3a0-4692-97ef-853fdb132a96">

- 프로세스를 구성하는 독립적인 실행 단위로 같은 프로세스 내 다른 스레드와 메모리 영역 공유
- 하나의 실행 흐름이므로 실행과 관련된 데이터 필요
    - 독립적 : 고유한 스레드 ID, 프로그램 카운터 (PC), 레지스터 집합, 스택 영역
    - 프로세스 내 코드, 데이터, 힙 영역과 기타 운영체제 자원을 다른 스레드와 공유
    - 즉, 스택만 독립적으로 할당 받고, 나머지 영역은 서로 공유함
- 각 스레드는 스택 영역을 통해 **독립적인 실행 흐름**을 가짐

### 프로세스와 스레드 차이점

- 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유
    - 반면에, 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없음
- 메모리 영역 공유로 인해 한 스레드에서 오류 발생 시 같은 프로세스 내의 다른 스레드 모두가 강제로 종료됨
    - 프로세스는 한 프로세스가 강제 종료되어도 다른 프로세스에게 영향을 주지 않음
        - if 공유 자원을 손상시키는 경우가 아닐 때

---

## 멀티 프로세스와 멀티 스레드

### Concurrent vs Parallel

<img width="712" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/5ffba662-c1f0-4e15-9a7e-72704e749d7d">

- Concurrent : 작업 여러 개가 동시에 처리된다는 개념
- Parallel : 한 작업을 쪼개 여러 서브 작업으로 분리, 물리적으로 분리된 구조에서 동시 처리해 수행하는 개념

### 멀티 프로세스 (Multi-Process)

- 한 프로그램을 여러 프로세스로 구성해 각 프로세스가 병렬적으로 작업을 수행
- ex) 크롬 브라우저 - 멀티 프로세스 구조
    - 대부분의 브라우저는 탭 브라우징을 지원
    - 브라우저의 각 탭은 (Renderer) 프로세스이며, 이들은 각자 독립적으로 실행
    - 하나의 웹 사이트가 비정상 종료되어도 다른 프로세스는 영향을 받지 않음
    - 그 외 크롬 지원 프로세스
        - **브라우저 프로세스** : 사용자 인터페이스와 디스크 및 네트워크 I/O를 관리
        - **Renderer 프로세스** : 웹 페이지 렌더링을 위한 로직(HTML, JavaScript, 이미지 등)을 포함
        - **플러그인 프로세스** : QuickTime과 같은 각 플러그인 유형에 대해 플러그인 프로세스 생성

### 멀티 프로세스의 통신 방법

- 독립적인 메모리 영역을 가지는 프로세스끼리의 통신 방법
- 데이터 교환을 위한 IPC 메커니즘이 필요
- IPC? (Inter-Process Communication)
    
    <img width="689" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/ab9ab780-f3ef-48d4-a9d4-254244f6ef95">
    
    - 공유 메모리 (shared memory) 와 메시지 전달 (message passing) 모델
    - 공유 메모리 : 프로세스가 공유하는 메모리 영역 설정, 각 프로세스는 공유 영역에서 데이터를 읽기/쓰기
    - 메시지 전달 : 프로세스 간 메시지를 교환하며 통신
    - 프로세스는 **완전히 독립된 실행객체**이므로 커널 영역에서 IPC라는 내부 프로세스간 통신을 제공하게 되고, 프로세스는 커널이 제공하는 IPC설비를 이용해서 프로세스간 통신을 하게 된다.

### 멀티 프로세스의 장단점

- 장점
    - 독립된 구조를 가지기 때문에 안전성이 높음 → 메모리 침범 문제를 OS에서 해결
    - 하나의 프로세스가 비정상적 종료되어도 자식 프로세스 외 다른 프로세스들은 아무런 영향을 받지 않음
- 단점
    - 독립된 메모리 영역을 가져 Context Switching을 위한 오버헤드(캐시 초기화 등)가 발생
    - Context Switching이 빈번하게 일어나면 성능 저하를 유발

### 멀티 스레드 (Multi-Thread)

- 한 프로세스에서 여러 개의 쓰레드를 동시에 수행

<img width="659" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/d68353f5-ecab-449d-8a8d-27503b3348ae">

- 멀티 스레드 예시
    - 웹 서버 프로세스 : 클라이언트 요청에 대한 별도의 스레드 생성
        - 새 프로세스 생성보다 비용적인 측면에서 훨씬 효율적
    - 운영체제의 커널 : Linux 시스템 부팅 시 여러 커널 스레드가 생성, 각 스레드는 장치 관리, 메모리 관리 또는 인터럽트 처리와 같은 특정 작업 수행
        - ps -ef 명령 등 실행 중인 Linux 시스템에서 커널 스레드를 표시
    - 웹 브라우저 : 하나의 스레드에서 이미지나 텍스트를 표시, 또 다른 스레드에서 네트워크로 데이터 검색
    - 워드 프로세서 : 그래픽 표시 스레드, 사용자 키 입력 스레드, 백그라운드에서 맞춤법 및 문법 검사 스레드

### 멀티 스레드의 장단점

- 장점
    - 단일 스레드는 작업 완료까지 응답을 기다림, 멀티 스레드를 사용함으로서 응답성 향상
    - 자원 공유성, 스레드는 자신이 속한 프로세스의 자원을 공유하여 **동일한 주소 공간 내 여러 스레드**를 가짐
    - 스레드는 자신이 속한 프로세스의 자원을 공유하므로 스레드 생성 및 Context-Switching 비용 단축
- 단점
    - 스레드는 프로세스 내 자원 공유, 스레드 하나에서 오류가 발생 시 같은 프로세스 내 모든 스레드 종료
    - 공유 자원에 대한 동기화 문제를 고려

---

## 스케줄링

### 프로세스 스케줄링

- 멀티 프로그래밍과 time sharing의 목적을 위해 실행 가능한 여러 프로세스 중 한 프로세스를 선택해 실행
- 멀티 프로그래밍 (multiprogramming) : CPU 사용률 최대화를 위해 항상 프로세스 실행
    - 한 프로세스가 CPU를 사용하다 I/O 작업 등 CPU가 필요 없을 때 다른 프로세스가 CPU를 사용
- 시분할 (time sharing) : 사용자들의 상호작용을 위해 프로세스 간 CPU 코어를 자주 전환하는 것

### 프로세스 상태

<img width="698" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/4992744d-c7e4-43b8-a972-e84a68f1577e">

- New : 프로세스 생성 / Running : 프로세스 지침 실행
- Waiting : 이벤트 발생을 기다림 (I/O or 신호 수신 이벤트 등, Blocked)
- Ready : 프로세서 할당을 기다림 / Terminated : 프로세스 실행을 끝냄

### 프로세스 상태 전이

- 승인 (Admitted) : 프로세스 생성 가능, 승인
- 스케줄러 디스패치 (Scheduler Dispatch) : 준비 상태 프로세스 중 하나를 선택해 실행
- 인터럽트 (Interrupt) : 예외, 입출력 등이 발생, 실행 중인 프로세스를 준비 상태로 변경, 해당 작업 먼저 처리
- 입출력/이벤트 대기 (I/O or event wait) : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우
    - → 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만듬
- 입출력/이벤트 완료 (I/O or event completion) : 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환
    - → 스케줄러에 의해 선택될 수 있도록 만듬

## CPU 스케줄링

- CPU 스케줄링은 Ready Queue에 있는 프로세스들을 대상으로 이루어진다.
- Ready Queue?
    - 프로세스가 시스템에 들어오면 ready queue에 들어가 CPU 코어에서 실행되기를 기다림
    - Linked List 형태로 저장
    - ready queue의 header는 list의 첫번째 PCB를 가리킴
    - 각 PCB의 포인터는 ready queue에 있는 다음 PCB를 가리킴
- Wait Queue?
    - 특정 이벤트 처리 완료를 기다리는 프로세스가 wait queue에 배치됨
    - 프로세스는 waiting 상태에서 ready 상태로 바뀌면 ready queue에 들어감

### 선점 / 비선점 스케줄링 (Preemptive and Non-preemptive Scheduling)

- CPU 스케줄링이 발생하는 4가지 상황
    1. running → waiting (I/O 요청, 하위 프로세스 종료를 위한 wait() 호출)
    2. running → ready (Interrupt 발생)
    3. waiting → ready (I/O 완료)
    4. 프로세스 종료
- 상황 1과 4에서 선택권 없이 새 프로세스를 선택하지만, 상황 2, 3에서는 다음과 같은 선택권 존재
    - 선점 스케줄링 : 어떤 프로세스가 CPU를 점유하고 있을 때 다른 프로세스가 CPU를 선점할 수 있다.
    - 비선점 스케줄링 : CPU가 할당된 어떤 프로세스는 종료 / waiting 상태로 전환하여 CPU를 해제할 때까지 CPU를 유지하고, 다른 프로세스는 그 때까지 CPU를 사용할 수 없다.
- 선점 스케줄링
    - OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우
    - 어떤 프로세스가 CPU를 점유하고 있을 때 다른 프로세스가 CPU를 선점 가능
    - 처리시간 예측이 어렵다.
    - Windows, macOS, Linux 및 UNIX를 포함 최신 운영체제는 선점 스케줄링 알고리즘 사용
    - Interrupt, I/O or event completion, I/O or event wait, exit
- 비선점 스케줄링
    - 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장
        - CPU를 해제할 때까지 CPU를 유지
        - 다른 프로세스는 그 때까지 CPU를 사용 불가
    - 처리시간 예측이 용이하다.
    - I/O or event wait, exit

---

## 스케줄링 알고리즘

### 선점 스케줄링

- 1) Round-Robin (RR)
    - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 Time Quantum 만큼 CPU를 할당
        - Time Quantum (Time Slice) : 실행 최소 단위 시간 (할당시간)
    - Time quantum 설정 시 주의할 점
        - 할당 시간이 크면 FCFS와 같고, 작으면 문맥 교환(Context Switching)이 잦아져 오버헤드 증가
- 2) Priority Scheduling
    - 정적/동적으로 우선순위를 부여해 우선순위가 높은 순서대로 CPU를 할당하는 스케줄링
    - 선점 / 비선점 스케줄링 모두 가능
    - 문제점
        - Starvation
            - 외부에서 새 프로세스 진입, 해당 프로세스 우선 순위가 높으면 기다린 프로세스보다 먼저 작업
            - 우선 순위가 낮은 일부 프로세스는 무기한 대기 상태가 될 수 있다.
    - 해결 방안
        - Aging, Round-Robin과 결합
        - Aging : 오랫동안 대기하는 프로세스의 우선순위를 점진적으로 높이는 방식
            - ex) 대기 중인 프로세스의 우선순위를 매초 늘림
        - RR+PS : 우선순위가 가장 높은 프로세스를 실행하는데, 동일한 우선순위의 프로세스에 대해서는 Round-Robin 스케줄링 적용
- 3) Multilevel-Queue (다단계 큐)
    - 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 Time quantum을 설정
    - 우선순위가 높은 큐는 작은 Time quantum할당, 우선순위가 낮은 큐는 큰 Time quantum 할당.
- 4) Multilevel-Feedback-Queue (다단계 피드백 큐)
    - 다단계 큐에서 자신의 Time quantum 다 채운 프로세스는 밑으로 내려감
    - 자신의 Time quantum을 다 채우지 못한 프로세스는 원래 큐와 동일
        - Time quantum을 다 채운 프로세스는 CPU burst 프로세스로 판단하기 때문
    - 짧은 작업에 유리, 입출력 위주의 Interrupt가 잦은 작업에 우선권을 줌

### 비선점 스케줄링

- 1) FCFS (First-Come, First-Served)
    - 먼저 CPU를 요청하는 프로세스에 먼저 CPU가 할당
    - FIFO queue 를 사용해 쉽게 구현할 수 있다.
    - 문제점
        - convoy effect : 먼저 들어온 어떤 프로세스 CPU 처리 시간이 길 경우 다른 모든 프로세스들 대기
            - 더 짧은 프로세스가 먼저 진행될 수 있는 경우보다 CPU 및 장치 사용률이 낮아지는 현상
- 2) SJF (Shortest-Job-First)
    - 비선점 방식
        - CPU burst time이 가장 작은 프로세스에게 먼저 CPU를 할당한다.
        - 만일 CPU burst time이 같다면, FCFS 방식을 적용한다.
        - burst time? — CPU가 일을 수행하는 시간
    - 선점 방식 (SRTF, Shortest-Remaining-Time-First)
        - 새로 들어온 프로세스 CPU burst time이 현재 실행 중인 프로세스의 남은 burst time 보다 작다면 현재 실행 중인 프로세스를 새로 들어온 프로세스가 선점
    - 문제점
        - starvation : CPU 처리 시간이 길면 프로세스가 계속 Ready queue의 뒤로 밀려나 무한정 대기
- 3) HRN (Hightest Response-ratio Next)
    - 우선순위를 계산하여 점유 불평등을 보완 (SJF 단점 보완)
    - 우선순위 = (대기시간 + 실행시간) / (실행시간)

### CPU 스케줄링 척도

- Response Time : 작업이 처음 실행되기까지 걸린 시간
- Turnaround Time (반환) : 실행 시간과 대기 시간을 모두 합한 시간으로 작업이 완료될 때까지 걸린 시간

---

## 동기 vs 비동기

<img width="521" alt="image" src="https://github.com/SWM-IDLE/tech-interview/assets/97138841/e7d49745-8137-40d8-8e16-afeb44764acc">

<aside>
💡 동기와 비동기는 호출되는 함수의 완료를 호출한 쪽에서 또는 호출 받은 쪽에서 신경을 쓰냐의 차이

</aside>

### 동기 **(Synchronous)**

- 데이터 요청과 결과가 한 자리에서 동시에 일어나는 것
- 요청하면 시간이 얼마나 걸리던 요청한 자리에서 결과가 주어져야함
- 장점
    - 설계가 매우 간단하고 직관적
- 단점
    - 결과가 주어질 때까지 아무것도 못하고 대기해야 함

### 비동기 **(Asynchronous)**

- 동시에 일어나지 않는다는 의미로 요청한 결과는 동시에 일어나지 않을 것이라는 약속
- 서버에 데이터 요청 후 요청에 따른 응답을 계속 기다리지 않아도 됨
- 장점
    - 요청에 따른 결과가 반환되는 시간동안 다른 작업 수행 가능
- 단점
    - 동기식보다 설계가 복잡

<aside>
💡 Blocking은 호출받은 쪽이 호출한 쪽에 제어권을 넘겨주지 않는 것, Non-blocking은 다시 제어권을 넘겨 주는 것

</aside>

### 블록 (Block)

- 동기의 개념에서 만들어진 상태
- 브라우저가 오픈되기 전까지 다른 브라우저는 계속 대기해야 하는 상태

### 논블록 (Non-Block)

- 비동기 개념에서 만들어진 상태
- 브라우저가 오픈되기 전까지 다른 브라우저는 시간을 대기하지 않고 제약없이 자유롭게 사용할 수 있는 상황

---

## 프로세스 동기화

### Critical Section(임계구역)

- 동일한 자원을 동시에 접근하는 작업을 실행하는 코드영역
- 멀티 쓰레딩의 문제점 발생

### Ctritical Section Problem

- 공통(data) 영역에 하나의 프로세스(task, thread)만 들어 갈 수 있도록 설계하는 것
- 이러한 설계를 위해서는 세가지 요구조건 충족
- 1) Mutual Exclusion(상호배타)
    - 어떠한 Task(Thread)가 임계구역을 사용중이면 다른 Task는 사용 불가
- 2) Progress
    - 현재 임계구역을 사용중인 Task가 없고, 임계구역에 들어가길 원하는 Task 가 있다면 바로 들여보냄
- 3) Bounded Waiting
    - 한정된 대기시간을 가져야 함 → 무한 대기 X

### 해결방법 (Hardware)

1. Memory Barriers
2. Compare & Swap
3. Atomic Variables

### 해결방법 (Software)

1. Mutex Lock (hardware-based)
    1. Task가 임계구역에 들어갈 때 acquire() 하고 나올 때 release()
    2. 한 Task만 임계구역에 들어갈 수 있게 함 → ex) 화장실 칸 한개 열쇠 한개!
    3. 문제점 —> Busy waiting(spin lock)으로 인해 효율 감소
2. Semaphores
    1. 임계구역에 들어갈 수 있는 task의 수
    2. 임계구역에 상호 배타적으로 들어 갈 수 있는 것 → ex) 화장실 안에 칸(자원) n개 , 전광판에 n 표시
    3. Semaphore = 1 이면 Mutex Lock 과 같은 방식으로 움직임
    4. Busy waiting을 사용하는 구현은 임계구역은 있지만, 사용하고자 하는 Task의 수가 적을 때 사용

### **Mutex Lock 과 Semaphore 의 차이!**

- Semaphore 는 Mutex Lock이 될 수 있지만 역은 성립하지 않음
- Semaphore 는 프로세스 범위에서 소유 불가능
    - Mutex는 소유 가능
- Mutex Lock 은 Lock을 갖고 있는 thread 해제 가능
    - Semaphore는 외부에서도 해제 가능
- Semaphore 는 시스템 범위에 걸쳐져 있고 파일형태로 존재
    - Mutex Lock은 프로세스 범위 내에 있어 종료시 자동으로 clean up

---

## 가상 메모리

### 가상 메모리란?

- 프로세스 전체가 메모리 내에 올라오지 않더라도 실행히 가능하도록 하는 기법
- 필요한 부분만 메모리에 올려 메모리에 올라가는 프로세스 크기를 줄이는 요구 페이징 기법 사용
- 장점
    - 프로세스 이미지를 모두 메모리에 올릴 필요가 없어져, 메모리 용량 부족 이슈 해결
- 프로세스들이 메모리를 공유하는 것을 가능하게 함
- 프로세스들은 공유 메모리를 통해 통신함
- fork()를 통한 프로세스 생성과정에서 페이지들 공유

### 요구 페이징 (Demand Paging)

- 프로그램 실행 시작 시 프로그램 전체를 디스크 물리 메모리에 적재하지만, 초기 필요한 것들만 적재하는 전략
- 가상 메모리 시스템에서 많이 사용되며, 가상 메모리는 페이지로 관리됨
- 요구페이징을 사용하는 가상메모리에서는 실행과정에서 필요해질 때 페이지들 적재
    - 한번도 접근되지 않은 페이지는 물리 메모리에 적재 X

---

## 페이징과 세그먼테이션

- 다중 프로그래밍 시스템 내 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요하여 생겨난 기법

### 용어 정리

- 페이지 : 고정 사이즈의 작은 프로세스 조각
- 프레임 : 페이지 크기와 같은 주기억장치 메모리 조각
- 단편화 : 기억 장치의 빈 공간 또는 자료가 여러 조각으로 나뉘는 현상
- 세그먼트 : 서로 다른 크기를 가진 논리적 블록이 연속적 공간에 배치되는 것

### 메모리 관리 기법

1. 연속 메모리 관리
    - 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야 함
    - 고정 분할 기법
        - 주기억장치가 고정된 파티션으로 분할 (내부 단편화)
    - 동적 분할 기법
        - 파티션들이 동적 생성됨, 자신의 크기와 같은 파티션에 적재 (외부 단편화)
2. 불연속 메모리 관리
    - 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
    - 고정 크기 : 페이징(Paging)
    - 가변 크기 : 세그먼테이션(Segmentation)
    - 단순 페이징
        - 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨
        - 외부 단편화 X —> 소량의 내부 단편화 존재
    - 단순 세그먼테이션
        - 각 프로세스는 여러 세그먼트들로 나뉨
        - 내부 단편화 X —> 외부 단편화 존재
        - 메모리 사용 효율을 개선하고, 동적 분할을 통한 오버헤드 감소
    - 가상 메모리 페이징
        - 단순 페이징과 비교해 프로세스 페이지 전부를 로드시킬 필요 없음
            - 필요한 페이지가 있으면 나중에 자동으로 불러옴
        - 외부 단편화 X —> 복잡한 메모리 관리 = 오버헤드 발생
    - 가상 메모리 세그먼테이션
        - 필요하지 않은 세그먼트들은 로드되지 않음
            - 필요한 세그먼트 있을때 나중에 자동으로 불러옴
        - 내부 단편화X —> 복잡한 메모리 관리 = 오버헤드 발생

---

## 페이지 교체 알고리즘

### 페이지 교체

- 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 Page Fault (페이지 부재)가 발생
- 이후, 원하는 페이지를 보조저장장치에서 가져오지만, 물리 메모리가 모두 사용중이라면 페이지 교체

### 페이지 교체 흐름

1. 디스크에서 필요한 페이지의 위치 검색
2. 빈 페이지 프레임 검색
    1. 페이지 교체 알고리즘을 통해 희생될 페이지를 고름
    2. 희생될 페이지를 디스크에 기록, 관련 페이지 테이블 수정
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지 Read, 프레임 테이블 수정
4. 사용자 프로세스 재시작

### 1) FIFO (First-in First-out)

- 메모리에 먼저 들어온 페이지 순서대로 페이지 교체 시점에 먼저 내보냄
- 장점
    - 이해하기 쉽고, 프로그래밍적 구현이 쉬움
- 단점
    - 오래된 페이지가 불필요한 정보를 포함한다고 보장 X
    - 처음부터 활발히 사용되는 페이지 교체 —> 페이지 부재율 상승
    - Belady의 모순 : 페이지 저장을 위해 프레임 개수를 늘려도, 페이지 부재가 더 많이 발생한다는 모순

### 2) 최적 페이지 교체 (Optimal Page Replacement)

- 모든 알고리즘보다 낮은 페이지 부재율을 보임, Belady의 모순 또한 발생하지 않음.
- 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체
- 주로 비교 연구 목적을 위해 사용 (실제론 잘 사용 X)
- 장점
    - 가장 낮은 페이지 부재율 보장
- 단점
    - 구현의 어려움
        - 모든 프로세스의 메모리 참조 계획을 미리 파악할 수 없음

### 3) LRU (Least-Recently-Used)

- 최적 알고리즘의 근사 알고리즘
- 가장 오랫동안 사용되지 않은 페이지를 선택해 교체
- OPT의 경우 미래 예측이지만, LRU의 경우는 과거를 보고 판단하므로 실질적으로 사용이 가능한 알고리즘
- 특징
    - FIFO < LRU < OPT

### 4) LFU Least-Frequently-Used)

- 참조 횟수가 가장 적은 페이지 교체
- 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정, 가설에서 출발
- 특징
    - 어떤 프로세스가 특정 페이지를 집중적으로 사용하다가 다른 기능을 사용
        - 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋 날 수 있음
    - OPT 알고리즘을 제대로, 근사하지 못해 잘 쓰이지 않음

### 5) MFU (Most-Frequently-Used)

- 참조 횟수가 가장 적은 페이지가 최근 메모리에 올라옴
    - 앞으로 계속 사용될 것이라는 가정, 가설에서 출발
- 특징
    - OPT 알고리즘을 제대로 근사하지 못해 잘 쓰이지 않음

### 교체 방식

- Global 교체 : 메모리 상 모든 프로세스 페이지에 대해 교체
- Local 교체 : 메모리 상 자기 프로세스 페이지에서만 교체
- 다양한 프로세스의 페이지가 메모리에 존재
    - 페이지 교체 시, 다양한 페이지 교체 알고리즘을 활용해 victim page를 선정
    - 선정 기준이 Global, Local 어떤 것인가에 대한 차이
- 실제 전체를 기준으로 페이지를 교체하는 것이 더 효율적
    - 자기 프로세스 페이지에서만 교체를 하면, 교체를 해야할 때 각각 모두 교체를 진행해야 하므로 비효율적

---

## 캐시

- 자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 장소
- 장점
    - 데이터를 미리 복사해 계산이나 접근 시간을 대폭 줄여 더 빠른 속도로 데이터 접근 가능
- 단점
    - 저장 공간이 작고 비용이 비쌈

### 캐시가 사용되는 좋은 경우

1. 업데이트가 자주 발생하지 않는 데이터
2. 반복적으로 동일한 결과를 돌려주는 경우
3. 자주 조회되는 데이터
- 캐시는 지속적으로 DBMS 혹은 서버에 요청하는것이 아닌, 메모리에 데이터를 저장하였다가 불러다 쓰는 것

### 지역성 (Locality)

- CPU에서 명령어를 수행하며 매번 캐시 메모리 참조, 이때 Hit rate가 지역성을 갖는다.
- 프로세스들이 기억장치 내의 정보를 균일하게 액세스 X, 어느 순간에 특정부분을 집중적으로 참조하는 것
    - 지역성은 메모리의 위치와 접근 시간에 따라서 공간적, 시간적인 특성을 보임
- 공간적 지역성
    - 한 번 참조한 메모리 옆에 있는 메모리를 다시 참조하게 된다는 특성
    - Array라는 일정한 메모리 공간을 순차적으로 할당받아 사용할 때, 공간 할당을 연속적으로 받음
    - 해당 Array 메모리가 사용되어질 때 연속적으로 사용될 가능성이 높아지는지
- 시간적 지역성
    - 한 번 참조된 주소의 내용은 곧 다음에 다시 참조된다는 특성
    - 반복문 사용 시, 특정 메모리값으로 선언된 부분을 반복하여 접근

### Local Cache vs Global Cache

- 캐시는 하드웨어가 아닌, 서버의 기준으로 로컬 캐시와 글로벌 캐시로 구분
- 로컬 캐시와 글로벌 캐시를 알맞게 선택 —> 시스템 성능 향상

### Local Cache

1. 서버마다 캐시를 따로 저장
2. 다른 서버의 캐시를 참조하기 어려움
3. 서버 내에서 작동하기 때문에 속도가 빠름
4. 로컬 서버 장비의 리소스를 이용한다. (리소스 : 메모리, 디스크)

### Global Cache

1. 여러 서버에서 캐시 서버에 접근하여 참조 할 수 있다.
2. 별도의 캐시 서버를 이용하기 때문에 서버 간 데이터 공유가 쉽다.
3. 네트워크 트래픽을 사용해야 해서 Local Cache보다 느리다.
4. 데이터를 분산하여 저장할 수 있다.

---

## 교착상태 (DeadLock)

- 교착상태는 상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상이다.

### 교착상태 발생의 필요 충분 조건

- 교착상태가 발생하기 위해서 다음 네 가지 조건을 충족해야함.
1. 상호배제 (Mutual Exclusion) : 한 번에 한 개의 프로세스만 공유 자원을 사용
2. 점유와 대기 (Hold and Wait) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스 존재
3. 비선점 (Non-preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗 X
4. 환형 대기 (Circular Wait) : 공유자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성, 자신에게 할당된 자원을 점유하면서 앞이나 뒤 프로세스의 자원을 요구

### 교착상태 해결 방법

- 1) 예방 (Prevention)
    - 교착상태가 발생하지 않도록 사전에 시스템 제어
    - 교착상태 발생의 네 가지 조건중에서 어느 하나를 제거하는 방법으로 자원 낭비가 가장 심한 기법
        1. 상호 배제 부정 : 한 번에 여러개의 프로세스가 공유 자원을 사용
        2. 점유 및 대기 부정 : 프로세스가 실행되기 전 필요한 모든 자원을 할당하여 프로세스 대기를 없애거나, 자원이 점유되지 않은 상태에서만 자원 요구
        3. 비선점 부정 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때, 점유하고 있는 자원을 반납 및 요구한 자원을 사용하기 위해 대기
        4. 환형 대기 부정 : 자원을 선형 순서로 분류하여 고유번호 할당, 각 프로세스는 현재 점유한 자원의 고유 번호보다 앞이나 뒤 어느 한쪽 방향으로만 자원을 요구
- 2) 회피 (Avoidance)
    - 교착상태가 발생할 가능성을 배제하지 않고, 교착상태가 발생하면 적절히 피해나가는 방법
    - 주로 은행원 알고리즘 (Banker's Algorithm) 사용
        - 다익스트라가 제안한 기법
        - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래한 기법
        - 각 프로세스에게 자원을 할당하여 교착상태가 발생하지 않음
        - 모든 프로세스가 완료될 수 있는 상태를 안전 상태(safe state)
        - 교착상태가 발생할 수 있는 상태를 불안전 상태(unsafe state)
        - 은행원 알고리즘을 적용하기 위해서 자원의 양과 프로세스 수 일정 보장
        - 은행원 알고리즘은 프로세스의 모든 요구를 유한한 시간안에 할당하는 것을 보장
- 3) 발견 (Detection)
    - 시스템에 교착상태가 발생했는지 점검, 교착상태에 있는 프로세스와 자원을 발견하는 기법
    - 발견 후 교착상태 회복(Recovery)을 수행, 발견기법과 회복기법을 함께 사용
- 4) 회복 (Recovery)
    - 교착상태 일으킨 프로세스 종료 또는 교착상태 프로세스에 할당된 자원을 선점해 프로세스나 자원을 회복
    - 크게 프로세스 종료와 자원 선점으로 구분
        1. 프로세스 종료
        - 프로세스 하나를 임의로 종료해 교착상태를 해결
            - 첫번째, 교착상태 프로세스를 모두 중지 —> 상당히 큰 비용 소모, 대신 단순
            - 두번째, 교착상태가 제거될 때까지 한 프로세스씩 중지 —> 각 프로세스가 중지될 때마다 교착상태를 확인해야하기 때문에, 상당한 오버헤드 유발
        1. 자원 선점
        - 교착상태가 깨질 때까지 프로세스로부터 자원을 계속적으로 선점해 다른 프로세스에게 건네야함
        - 희생자 선택 : 어떤 자원과 프로세스가 선점될 것인가 고려
            - 비용을 최소화 하기 위해 교착상태 프로세스가 점유하고 있는 자원의 수, 교착상태 프로세스가 지금까지 실행하는데 소요한 시간과 같은 변수를 고려하여 희생자 선택
        - 롤백 : 특정 프로세스 자원을 강제로 방출, 선점했다면 해당 프로세스를 어떻게 처리할 것인지 고려
            - 가장 안전한 방법은 프로세스를 중지하고 재시작하는 롤백
        - 기아 상태 : 특정 프로세스의 자원을 강제로 방출시켜 선점을 시켜주면, 그 프로세스는 계속해서 희생자가 될 확률이 높아짐
            - —> 영원히 실행이 완료되지 못하는 기아상태에 빠짐
            - 프로세스에 롤백 횟수 제한 두기
            - 또, 프로세스가 한정된 시간에만 희생자로 선정된다는 것을 반드시 보장해야함

---

## 질문

1. 메모리 영역 중 **힙 영역과 스택 영역의 차이점**은 무엇인가요?
    1. 힙은 동적 데이터를 저장하는 데 사용되며 프로그래머에 의해 관리됩니다. 
    2. 반면에, 스택은 로컬 변수와 함수 호출을 저장하는 데 사용되며 운영 체제에 의해 관리됩니다.
2. 메모리 영역 중 **런타임에 결정되는 영역**은 어디인가요?
    1. 힙 영역입니다. 나머지 코드, 데이터, 스택 영역은 컴파일 타임에 결정됩니다.
        1. 컴파일 타임과 런타임에 대해서 각각 설명해주세요.
            - 컴파일 타임은 소스코드가 기계어로 변환되는 과정을 말합니다. 컴파일 타임에 발생하는 대표적인 오류로는 Syntax Error가 존재합니다.
            - 런타임은 컴파일 타임 이후, 프로그램이 동작되어지는 때를 말합니다. 런타임에 발생하는 대표적인 오류로는 0으로 값을 나누는 ZeroDivisionError 등이 있습니다.
3. **Ready나 Block**도 Linked List로 관리하는데, PCB에서 이미 관리하는데 **왜 따로 관리**하는 것인가요?
    1. Process State는 PCB List에서 다 섞여있게 됩니다. CPU Scheduling은 Ready 상태인 Process를 가지고 하는데, PCB만 관리를 한다면 Ready만 다시 뽑아내야 하는 상태가 만들어집니다.
    2. 따라서 미리 Ready 등을 Linked List로 관리하여 빠른 동작과 수행을 만들려는 목적이 있습니다.
4. **문맥교환의 단점**을 간단히 말씀해주시고, 단점이 있음에도 **문맥교환을 수행해야하는 이유**는 무엇인가요?
    1. 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생한다는 단점이 존재합니다.
    2. 그럼에도 불구하고, CPU가 여러 개의 프로세스를 동시에 수행하려고 할 때 문맥교환을 사용할 수 있고 이는 CPU가 놀지 않도록 하여 사용자에게 빠르게 일처리를 제공하는 효율성이 존재하므로 필요합니다.
5. **멀티프로세스와 멀티스레드의 차이점**에 대해서 설명해주세요.
    1. 멀티 스레드는 멀티 프로세스보다 작은 메모리 공간을 차지하고 문맥교환이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험이 존재한다.
    2. 멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지하는 단점이 존재한다.
